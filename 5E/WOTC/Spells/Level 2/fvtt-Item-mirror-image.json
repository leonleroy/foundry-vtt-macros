{
  "name": "Mirror Image",
  "type": "spell",
  "img": "modules/plutonium/media/icon/spell/phb-mirror-image.webp",
  "data": {
    "description": {
      "value": "<div class=\"rd__b  rd__b--3\"><p>Three illusory duplicates of yourself appear in your space. Until the spell ends, the duplicates move with you and mimic your actions, shifting position so it's impossible to track which image is real. You can use your action to dismiss the illusory duplicates.</p><div class=\"rd__spc-inline-post\"></div><p>Each time a creature targets you with an attack during the spell's duration, roll a [[/r d20]] to determine whether the attack instead targets one of your duplicates.</p><p>If you have three duplicates, you must roll a 6 or higher to change the attack's target to a duplicate. With two duplicates, you must roll an 8 or higher. With one duplicate, you must roll an 11 or higher.</p><p>A duplicate's AC equals 10 + your Dexterity modifier. If an attack hits a duplicate, the duplicate is destroyed. A duplicate can be destroyed only by an attack that hits it. It ignores all other damage and effects. The spell ends when all three duplicates are destroyed.</p><p>A creature is unaffected by this spell if it can't see, if it relies on senses other than sight, such as blindsight, or if it can perceive illusions as false, as with <span class=\"help help--hover\" data-plut-hover=\"true\" data-plut-hover-preload=\"true\" data-plut-hover-preload-id=\"28\">truesight</span>.</p></div>",
      "chat": "",
      "unidentified": ""
    },
    "source": "PHB pg. 260",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "minute"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": "self"
    },
    "range": {
      "value": null,
      "long": null,
      "units": "self"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "int",
    "actionType": "util",
    "attackBonus": null,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "int"
    },
    "level": 2,
    "school": "ill",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": false
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": 0
  },
  "effects": [],
  "flags": {
    "srd5e": {
      "page": "spells.html",
      "source": "PHB",
      "hash": "mirror%20image_phb",
      "propDroppable": "spell"
    },
    "midi-qol": {
      "effectActivation": false,
      "forceCEOff": true,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "enhanced-terrain-layer": {
      "multiple": null,
      "elevation": null,
      "depth": null,
      "environment": ""
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Mirror Image",
          "type": "script",
          "author": "sGDyf0LH8KxxtfaW",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "// Requires the following modules: Item Macros, Times-Up, About-Time, MidiQOL, Token Magic FX\n// Original script: https://github.com/trioderegion/fvtt-macros/blob/legacy/0.7.x/honeybadger-macros/ItemMacro/MirrorImage.js\n// I also used ideas from theripper93/Discord macro attached on: 20210414\n// Macro version 1.02 // 20220402\n\nfunction deletecustomflags(tactor) {\n    let hookId = tactor.getFlag(\"world\", `mirrorImageHook`);\n    Hooks.off(\"midi-qol.preDamageRoll\", hookId);\n    tactor.unsetFlag(\"world\", `mirrorImageduperNr`);\n    tactor.unsetFlag(\"world\", `mirrorImagedupeAC`);\n    tactor.unsetFlag(\"world\", `mirrorImageHook`);\n}\n\nasync function make_effect(castertoken, imagesNR) {\n    let TMEffect = [{\n        filterType: \"images\",\n        filterId: \"myMirrorImages\",\n        time: 0,\n        nbImage: imagesNR + 1,\n        alphaImg: 1.0,\n        alphaChr: 0.0,\n        blend: 4,\n        ampX: 0.10,\n        ampY: 0.10,\n        zOrder: 20,\n        animated: {\n            time: {\n                active: true,\n                speed: 0.0010,\n                animType: \"move\"\n            }\n        }\n    }];\n    if (game.modules.get(\"tokenmagic\")?.active) {\n        await TokenMagic.deleteFilters(castertoken)\n        await TokenMagic.addFilters(castertoken, TMEffect);\n    }\n}\n\nif (args[0] === \"on\") {\n    return;\n}\n\nif (args[0] === \"off\") {\n    let caster = canvas.tokens.get(args[args.length - 1].tokenId).actor;\n    deletecustomflags(caster);\n    if (game.modules.get(\"tokenmagic\")?.active) TokenMagic.deleteFilters(canvas.tokens.get(args[args.length - 1].tokenId));\n    return;\n}\n\nlet caster = canvas.tokens.get(args[0].tokenId).actor;\nlet ttokenId = args[0].tokenId;\nlet existingEffect = caster.effects.find(e => e.data.label === item.name);\nif (existingEffect) return ui.notifications.warn(`${caster.name} is already equiped with ${item.name}.`);\n\nlet effectData = {\n    label: item.name,\n    icon: item.data.img,\n    \"duration\": {\n        \"rounds\": 10,\n        \"seconds\": 60,\n        \"startTime\": game.time.worldTime\n    },\n    origin: item.uuid,\n    changes: [{\n        key: \"macro.itemMacro\",\n        mode: 0,\n        value: `ItemMacro.${item.name} `,\n        priority: 20\n    }]\n};\n\nconst newId = await caster.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\nawait make_effect(canvas.tokens.get(ttokenId), 3)\nawait caster.setFlag(\"world\", `mirrorImageduperNr`, 3);\nawait caster.setFlag(\"world\", `mirrorImagedupeAC`, actor.data.data.abilities.dex.mod + 10);\nlet hookid = Hooks.on(\"midi-qol.preDamageRoll\", mirrorImageHook);\ncaster.setFlag(\"world\", `mirrorImageHook`, hookid);\n\nfunction mirrorImageHook(workflow) {\n    let dupeHit;\n    let echo;\n    let interruptdamage = false;\n    let actT = workflow.item.data.data.actionType;\n    if (actT != \"mwak\" && actT != \"rwak\" && actT != \"msak\" && actT != \"rsak\") return;\n    let indexNum;\n    for (let i = 0; i < workflow.hitTargets.size; i++) {\n        if (Array.from(workflow.hitTargets)[i].data._id == ttokenId) indexNum = i;\n    }\n    if (indexNum == undefined) return;\n\n    let dupecount = caster.getFlag(\"world\", `mirrorImageduperNr`);\n    const r = new Roll(\"1d20\");\n    r.evaluate({\n        async: false\n    });\n    const d20result = r._total;\n\n    switch (dupecount) {\n        case 1:\n            // > 10 = shatter\n            if (d20result > 10) dupeHit = true;\n            break;\n        case 2:\n            // > 7 = shatter\n            if (d20result > 7) dupeHit = true;\n            break;\n        case 3:\n            // >5 shatter\n            if (d20result > 5) dupeHit = true;\n            break;\n        default:\n            break;\n    }\n\n    if (dupeHit) {\n        if (workflow.attackTotal >= caster.getFlag(\"world\", `mirrorImagedupeAC`)) {\n            dupecount -= 1;\n            caster.setFlag(\"world\", `mirrorImageduperNr`, dupecount);\n            interruptdamage = true;\n            switch (dupecount) {\n                case 0:\n                    echo = `[[${d20result}]] All duplicates destroyed!`;\n                    if (caster.effects.find(e => e.data.label === item.name)) caster.effects.find(e => e.data.label === item.name).delete();\n                    if (game.modules.get(\"tokenmagic\")?.active) TokenMagic.deleteFilters(canvas.tokens.get(ttokenId));\n                    break;\n                case 1:\n                    echo = `[[${d20result}]] One duplicate remains...`;\n                    make_effect(canvas.tokens.get(ttokenId), 1)\n                    break;\n                case 2:\n                    echo = `[[${d20result}]] Shattered! Two duplicates remain`;\n                    make_effect(canvas.tokens.get(ttokenId), 2)\n                    break;\n            }\n        } else {\n            echo = `[[${d20result}]] The attack is redirected to a duplicate and misses!`;\n            interruptdamage = true;\n        }\n    } else {\n        if (workflow.attackTotal < caster.data.data.attributes.ac.value) {\n            echo = `[[${d20result}]] The attack misses you!`;\n            interruptdamage = true;\n        } else\n            echo = `[[${d20result}]] The attack hits you!`;\n    }\n\n    ChatMessage.create({\n        user: game.user._id,\n        speaker: ChatMessage.getSpeaker({\n            actor: actor\n        }),\n        content: echo,\n        type: CONST.CHAT_MESSAGE_TYPES.EMOTE\n    });\n\n    return !interruptdamage;\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "core": {
      "sourceId": "Item.ndMMNmevcbRPWykj"
    },
    "favtab": {
      "isFavorite": true
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "5etest",
      "system": "dnd5e",
      "coreVersion": "9.255",
      "systemVersion": "1.5.7"
    }
  }
}